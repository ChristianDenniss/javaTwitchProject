import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class TwitchChatProcessor extends Application
{
    private static final int LAYOUT_SPACING = 10; // Configurable spacing for layout
    private int[] messageCounts; // Array to count message values
    private boolean isEntryPeriodActive = false;
    private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);

    private Socket socket;
    private BufferedReader in;
    private PrintWriter out;

    private static final String SERVER = "irc.chat.twitch.tv"; // Twitch IRC server
    private static final int PORT = 6667; // IRC port
    private static final String OAUTH_TOKEN = "oauth:c3xr5w8x70tzgvy3ko8lb8lm9f0v8m"; // Replace with your OAuth token
    private static final String NICKNAME = "lopgop123"; // Replace with your username
    private static final String CHANNEL = "#lopgop123"; // Replace with the channel name you wish to connect to

    public static void main(String[] args)
    {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage)
    {
        VBox layout = new VBox(LAYOUT_SPACING);
        Label resultLabel = new Label("Press start to begin processing messages.");
        Label countLabel = new Label("Message Counts: 1: 0, 2: 0, 3: 0, 4: 0"); // Real-time count display
        Button startButton = new Button("Start Entry Period");

        startButton.setOnAction(event -> 
        {
            resultLabel.setText("Entry period active. Listening for messages...");
            countLabel.setText("Message Counts: 1: 0, 2: 0, 3: 0, 4: 0"); // Reset counts display
            startEntryPeriod(15, resultLabel, countLabel); // Start 15 seconds entry period
        });

        layout.getChildren().addAll(startButton, resultLabel, countLabel);
        Scene scene = new Scene(layout, 400, 200);
        primaryStage.setScene(scene);
        primaryStage.setTitle("Twitch Chat Processor");
        primaryStage.show();

        // Initialize Twitch IRC connection
        initializeTwitchClient();
    }

    private void initializeTwitchClient()
    {
        try
        {
            socket = new Socket(SERVER, PORT);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);

            // Authenticate and join channel
            out.println("PASS " + OAUTH_TOKEN);
            out.println("NICK " + NICKNAME);
            out.println("JOIN " + CHANNEL);

            // Start listening for messages
            new Thread(this::listenForMessages).start();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private void listenForMessages()
    {
        try
        {
            String line;
            while ((line = in.readLine()) != null)
            {
                System.out.println("Twitch IRC: " + line);
                if (line.startsWith("PING"))
                {
                    out.println("PONG :tmi.twitch.tv");
                }
                else if (line.contains("PRIVMSG"))
                {
                    String message = parseMessage(line);
                    processMessage(message);
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private String parseMessage(String rawLine)
    {
        int messageIndex = rawLine.indexOf(" :");
        return (messageIndex != -1) ? rawLine.substring(messageIndex + 2) : "";
    }

    private void startEntryPeriod(int seconds, Label resultLabel, Label countLabel)
    {
        messageCounts = new int[4]; // Reset counts
        isEntryPeriodActive = true;

        executor.schedule(() -> 
        {
            isEntryPeriodActive = false;
            Platform.runLater(() -> 
            {
                int result = determineMostFrequentMessage();
                if (result == -1) 
                {
                    resultLabel.setText("No messages received during the entry period.");
                } 
                else 
                {
                    resultLabel.setText("Entry period over. Most frequent message: " + result);
                }
            });
        }, seconds, TimeUnit.SECONDS);

        executor.scheduleAtFixedRate(() -> 
        {
            if (isEntryPeriodActive) 
            {
                Platform.runLater(() -> 
                {
                    countLabel.setText("Message Counts: 1: " + messageCounts[0] +
                            ", 2: " + messageCounts[1] + ", 3: " + messageCounts[2] + ", 4: " + messageCounts[3]);
                });
            }
        }, 0, 1, TimeUnit.SECONDS); // Update every second
    }

    public void processMessage(String message)
    {
        if (!isEntryPeriodActive) return;

        if ("1".equals(message) || "2".equals(message) || "3".equals(message) || "4".equals(message)) 
        {
            int value = Integer.parseInt(message);
            //we cant use value directly because the 0 index so we do value -1 and increment its count
            messageCounts[value-1]++; 
        }
    }

    private int determineMostFrequentMessage()
    {
        int mostFrequent = 0;
        int maxCount = 0;

        for (int i = 0; i < 4; i++) 
        {
            if (messageCounts[i] > maxCount) 
            {
                mostFrequent = i+1;
                maxCount = messageCounts[i];
            }
        }

        // If no messages were counted (max count=0) return -1 to indicate no messages received, else max count != to 0, return mostFrequent, this is a faster way to write it
        return maxCount == 0 ? -1 : mostFrequent;
    }
}
